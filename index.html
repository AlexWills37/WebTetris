<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>TetrisGL</title>
        <link rel="shortcut icon" type="image/x-icon" href="facivon.ico">
		<script type="module" crossorigin src="/WebTetris/assets/index-Sdg9HWFG.js"></script>
		<link rel="stylesheet" crossorigin href="/WebTetris/assets/index-DJN6ve2P.css">
	</head>
	<body>
        <canvas id="canvas"></canvas>

        <script id="vertex-shader-2d" type="notjs">
     
            // an attribute will receive data from a buffer
            attribute vec4 a_Position;
            attribute vec2 a_GridPos;
            attribute float a_ShaderID;
            attribute float a_QueueID;

            varying float v_ShaderID;
            varying vec4 v_Position;
            varying vec2 v_GridPos;
            varying float v_QueueID;
            
            uniform vec2 u_Resolution;

            // all shaders have a main function
            void main() {
                vec4 scaledPos = a_Position;
                if(u_Resolution.x > u_Resolution.y / 2.) {
                    // Grid takes up vertical space; scale x based on y
                    scaledPos.x = scaledPos.x * u_Resolution.y / u_Resolution.x;
                } else {
                    // Grid takes up horizontal space; scale y based on x
                    scaledPos.y = scaledPos.y * u_Resolution.x / u_Resolution.y;
                }
                gl_Position = scaledPos;
                v_GridPos = a_GridPos;
                v_ShaderID = a_ShaderID;
                if (a_ShaderID == 1.) {
                    v_QueueID = a_QueueID;
                }
            }
           
        </script>
        
        <script id="fragment-shader-2d" type="notjs">
            #version 100
            // fragment shaders don't have a default precision so we need
            // to pick one. mediump is a good default
            precision highp float;
            uniform float u_Time;

            uniform sampler2D u_GridData;
            uniform sampler2D u_BlockTexture;
            uniform sampler2D u_QueueData;

            varying vec4 v_Position;
            varying vec2 v_GridPos;
            varying float v_ShaderID;
            varying float v_QueueID;


            void main() {


                if (v_ShaderID == 0.) {
                    float p = 0.025;
                    // Background color
    
    
    
                    gl_FragColor = vec4(0.4, 0.4, 0.4, 1);
    
                    vec2 gridLoc = v_GridPos / vec2(10., 20.);
                    vec4 thisSquareData = texture2D(u_GridData, gridLoc);
                    if (thisSquareData !=  vec4(0, 0, 0, 1)) {
                        vec4 color = thisSquareData;
                        vec2 texCoord = vec2(fract(v_GridPos.x), 1. - fract(v_GridPos.y));
                        gl_FragColor = texture2D(u_BlockTexture, texCoord) * color;
                    }
    
                    // Grid lines
                    if (fract(v_GridPos.x) <= p || fract(v_GridPos.y) <= p || fract(v_GridPos.x) >= 1. - p || fract(v_GridPos.y) >= 1. - p) {
                        gl_FragColor = vec4(0, 0, 0, 1);
                    }
    
                } else {
                    gl_FragColor = vec4(vec3(0.35), 1);


                    if (v_GridPos.y >= 1. && v_GridPos.y < 3.) {
                        vec2 dataLocation = v_GridPos / vec2(4., 10.);
                        dataLocation.y += ((2. * v_QueueID - 1.)/10.);
                        vec4 blockData = texture2D(u_QueueData, dataLocation);
                        if (blockData != vec4(0, 0, 0, 1)) {

                            vec2 texCoord = fract(v_GridPos);
                            texCoord.y = 1. - texCoord.y;
                            vec4 texColor = texture2D(u_BlockTexture, texCoord);
                            gl_FragColor = blockData * texColor;
                        }
                    }

                    


                }

            }
        
        </script>

	</body>
</html>